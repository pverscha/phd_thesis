import Serializable from "./../encoding/Serializable";
/**
 * Special implementation of the Map API that internally uses ArrayBuffers for it's data storage. These buffers can be
 * easily transferred between threads with a zero-copy cost, which allows to gain a much higher communication speed
 * between threads. You need to call `getBuffers()` and `setBuffers()` and manually transfer the buffers for this map
 * between threads to use this benefits.
 *
 * NOTE: When no support for SharedArrayBuffers is available, this map will automatically fall back to regular
 * ArrayBuffers, which can also be transferred between threads (but cannot be used by multiple threads at the same
 * time).
 *
 * Note: This Map currently does not support deleting items or changing the values that belong to a key since this
 * would require extensive memory alignment and management.
 *
 * @author Pieter Verschaffelt
 */
export default class ShareableMap<K, V> extends Map<K, V> {
    private readonly serializer?;
    private static readonly LOAD_FACTOR;
    private static readonly INT_SIZE;
    private static readonly INVALID_VALUE;
    private static readonly DATA_OBJECT_OFFSET;
    private static readonly INDEX_TABLE_OFFSET;
    private index;
    private data;
    private indexView;
    private dataView;
    private textEncoder;
    private textDecoder;
    /**
     * Construct a new ShareableMap.
     *
     * @param expectedSize How many items are expected to be stored in this map? Setting this to a good estimate from
     * the beginning is important not to trash performance.
     * @param averageBytesPerValue What's the expected average size of one serialized value that will be stored in this
     * map?
     * @param serializer Custom serializer to convert the objects stored in this map as a value to an ArrayBuffer and
     * vice-versa.
     */
    constructor(expectedSize?: number, averageBytesPerValue?: number, serializer?: Serializable<V> | undefined);
    /**
     * Get the internal buffers that represent this map and that can be transferred without cost between threads. Use
     * setBuffers() to rebuild a ShareableMap after the buffers have been transferred.
     */
    getBuffers(): ArrayBuffer[];
    /**
     * Set the internal buffers that represent this map and that can be transferred without cost between threads.
     *
     * @param indexBuffer Index table buffer that's used to keep track of which values are stored where in the
     * dataBuffer.
     * @param dataBuffer Portion of memory in which all the data itself is stored.
     */
    setBuffers(indexBuffer: ArrayBuffer, dataBuffer: ArrayBuffer): void;
    [Symbol.iterator](): IterableIterator<[K, V]>;
    entries(): IterableIterator<[K, V]>;
    keys(): IterableIterator<K>;
    values(): IterableIterator<V>;
    clear(expectedSize?: number, averageBytesPerValue?: number): void;
    delete(key: K): boolean;
    forEach(callbackfn: (value: V, key: K, map: Map<K, V>) => void, thisArg?: any): void;
    get(key: K): V | undefined;
    has(key: K): boolean;
    set(key: K, value: V): this;
    get size(): number;
    /**
     * @return The amount of buckets that are currently available in this map (either taken or not-taken, the total
     * number of buckets is returned).
     */
    private get buckets();
    /**
     * @return The amount of buckets that currently point to a data object.
     */
    private getBucketsInUse;
    /**
     * Increase the amount of buckets that currently point to a data object by one.
     */
    private incrementBucketsInUse;
    /**
     * At what position in the data-array does the next block of free space start? This position is returned as number
     * of bytes since the start of the array.
     */
    private get freeStart();
    /**
     * Update the position where the next block of free space in the data array starts.
     *
     * @param position The new position that should be set. Must indicate the amount of bytes from the start of the
     * data array.
     */
    private set freeStart(value);
    /**
     * @return Total current length of the data array in bytes.
     */
    private get dataSize();
    /**
     * Update the total length of the data array.
     *
     * @param size New length value, in bytes.
     */
    private set dataSize(value);
    /**
     * Increase the size counter by one. This counter keeps track of how many items are currently stored in this map.
     */
    private increaseSize;
    /**
     * Allocate a new ArrayBuffer that's twice the size of the previous buffer and copy all contents from the old to the
     * new buffer. This method should be called when not enough free space is available for elements to be stored.
     */
    private doubleDataStorage;
    /**
     * Call this function if the effective load factor of the map is higher than the allowed load factor (default 0.75).
     * This method will double the amount of available buckets and make sure all pointers are placed in the correct
     * location.
     */
    private doubleIndexStorage;
    private encodeObject;
    /**
     * Encode a string value and store into the given view. This function returns the amount of bytes that are used
     * for the encoded string.
     *
     * @param stringValue String value that should be encoded into the array.
     * @param view View of the array in which the encoded result is stored.
     * @return The number of bytes that are used for the encoded string result.
     */
    private encodeString;
    private encodeKey;
    private encodeValue;
    /**
     * Allocates some space in the data array to store a new data object. Such a data object keeps track of it's
     * internal length, points to the next item in the current linked list of objects and keeps track of it's key and
     * value.
     *
     * @param key The key that identifies the given value.
     * @param value The value that's associated with the given key.
     */
    private storeDataBlock;
    /**
     * Update a data object's pointer to the next object in a linked list.
     *
     * @param startPos The starting position of the data object whose "next"-pointer needs to be updated.
     * @param nextBlock Value of the "next"-pointer that either points to a valid starting position of a data object, or
     * a 0 if this is the last object in a linked chain of objects.
     */
    private updateLinkedPointer;
    /**
     * Start looking for a specific key in a given link of data objects and return the associated value. The starting
     * position given to this function should point to the first data object in the link that's to be examined. If the
     * key is not found at this position, the pointer to the next data object is followed until either the key is found,
     * or no link to the following object exists.
     *
     * @param startPos Position of the first data object in the linked list that should be examined.
     * @param key The key that we're currently looking for.
     * @return The starting position of the data object and value associated with the given key. If no such key was
     * found, undefined is returned.
     */
    private findValue;
    /**
     * Returns the key associated with the data object starting at the given starting position.
     *
     * @param startPos The starting position of the data object from which the associated key should be extracted.
     */
    private readKeyFromDataObject;
    private readTypedKeyFromDataObject;
    /**
     * Returns the value associated with the data object starting at the given starting position.
     *
     * @param startPos The starting position of the data object from which the associated value should be returned.
     */
    private readValueFromDataObject;
    /**
     * Clear all contents of this map and return to the initial configuration.
     *
     * @param expectedSize How many elements are expected to be stored in this map? Setting this value initially to a
     * good estimate could help with improving performance for this map.
     * @param averageBytesPerValue how large do we expect one value element to be on average. Setting this to a good
     * estimate can improve performance of this map.
     */
    private reset;
}
